# 位操作符

位操作符用于数值的底层操作，也就是操作内存中表示数据的比特（位）。ECMAScript 中的所有数值都以 IEEE 754 64 位格式存储，但位操作并不直接应用到 64 位表示，而是先把值转换为 32 位整数，再进行位操作，之后再把结果转换为 64 位。对开发者而言，就好像只有 32 位整数一样，因为 64 位整数存储格式是不可见的。所以只需要考虑 32 位整数即可。

有符号整数使用 32 位的前 31 位表示整数值。第 32 位表示数值的符号，如 0 表示正，1 表示负。这一位称为符号位（sign bit）。
|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|
|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|
|符号位|||

## 正值

正值以二进制格式存储。一共 31 位，每一位都是 2 的幂。第一位（第 0 位）表示 2 的 0 次方，第二位表示 2 的 1 次方，依此类推。空位以 0 填充。

比如，数值 18 的二进制格式为 00000000000000000000000000010010，精简为 10010。后者是用到的 5 个有效位：
|1|0|0|1|0|
|--|--|--|--|--|
|1*2\*\*4 | 0*2**3|0\*2**2|1*2\*\*1|0*2\*\*0|
|16|0|0|2|0|
|||和为 18|||

## 负值

负值以二补数（补码）的二进制编码存储。二补数通过三个步骤计算得到：

1. 得到绝对值的二进制
2. 把 1 都变成 0，0 都变成 1，获得一补数（反码）
3. 给结果加 1

基于上述步骤确定-18 的二进制表示：

18 的绝对值

0000 0000 0000 0000 0000 0000 0001 0010

计算一补数，即反转每一位的二进制值：

1111 1111 1111 1111 1111 1111 1110 1101

最后，给一补数加 1：

1111 1111 1111 1111 1111 1111 1110 1110

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1

---

1111 1111 1111 1111 1111 1111 1110 1110

不过在把负值输出为一个二进制字符串时，我们会得到一个前面加了减号的绝对值：

```javascript
let num = -18;
console.log(num.toString(2)); // "-10010"
```

> 默认情况下，ECMAScript 中的所有整数都表示为有符号数。不过，确实存在无符
> 号整数。对无符号整数来说，第 32 位（第 31 位）不表示符号，因为只有正值。无符号整数比有符号
> 整数的范围更大，因为符号位被用来表示数值了。

在对 ECMAScript 中的数值应用位操作符时，后台会发生转换：64 位数值会转换为 32 位数值，然后执行位操作，最后再把结果从 32 位转换为 64 位存储起来。这个转换导致了一个奇特的副作用，特殊值 NaN 和 Infinity 在位操作中会被当成 0 处理。

如果将位操作符应用到非数值，会先用 Number()转换。最终结果是数值。

## 按位非

用~表示，返回数值的一补数（反码）。
按位非可以返回数值的负值并减 1：

```javascript
let num1 = 25; // 二进制00000000000000000000000000011001
let num2 = ~num1; // 二进制11111111111111111111111111100110
console.log(num2); // -26
```

并且这个操作比直接下面这样的速度要快得多：

```javascript
let num1 = 25;
let num2 = -num1 - 1;
console.log(num2); // "-26"
```

## 按位与

用&表示。按位与会将两个数的每个位对齐，然后基于真值表中的规则，贵每一位执行与操作。

| 第一个数值的位 | 第二个数值的位 | 结 果 |
| -------------- | -------------- | ----- |
| 1              | 1              | 1     |
| 1              | 0              | 0     |
| 0              | 1              | 0     |
| 0              | 0              | 0     |

我们对数值 25 和 3 进行按位与：

```javascript
let result = 25 & 3;
console.log(result); // 1
```

这个过程发生了什么呢？

&nbsp;&nbsp;&nbsp;&nbsp;25 = 0000 0000 0000 0000 0000 0000 0001 1001

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3 = 0000 0000 0000 0000 0000 0000 0000 0011

---

AND = 0000 0000 0000 0000 0000 0000 0000 0001

## 按位或

用|表示。遵循
| 第一个数值的位 | 第二个数值的位 | 结 果 |
| -------------- | -------------- | ----- |
| 1 | 1 | 1 |
| 1 | 0 | 1 |
| 0 | 1 | 1 |
| 0 | 0 | 0 |
其他都和按位与一样，不再重复举例。

## 按位异或

用^表示。遵循
| 第一个数值的位 | 第二个数值的位 | 结 果 |
| -------------- | -------------- | ----- |
| 1 | 1 | 0 |
| 1 | 0 | 1 |
| 0 | 1 | 1 |
| 0 | 0 | 0 |
同上

## 左移

左移操作符用<<表示。会按照指定的位数将数值的所有位向左移动。

```javascript
let oldValue = 2;
let newValue = oldValue << 5; // 64
```

数值 2 的二进制是：
10
左移 5 位后得到了：
1000000
这个二进制数的十进制是 64。

左移会保留操作数的符号。如果刚才操作的是-2，得到的就是-64。

## 有符号右移

有符号右移用>>表示。它会将所有的 32 位都往右移，同时保留符号。

```javascript
let oldValue = 64; // 等于二进制1000000
let newValue = oldValue >> 5; // 5
```

## 无符号右移

无符号右移用>>>表示。对于正数，操作和有符号右移一样。对于负数则不同。

```javascript
let oldValue = -64; // 等于二进制11111111111111111111111111000000
let newValue = oldValue >>> 5; // 等于十进制134217726
```

这是因为 64 的二进制表示是 11111111111111111111111111000000，右移 5 位得到 00000111111111111111111111111110，转换为十进制的 134 217 726。

# 相等操作符

ECMAScript 提供了两组相等操作符，可以按需使用。

第一组是等于和不等于，他们在比较之前执行转换。
第二组是全等和不全等，他们在比较之前不转换。

## 等于==和不等于!=

等于操作符用==表示，如果操作数相等则返回 true，否则返回 false。

不等于操作符用！=表示，如果操作数不相等则返回 true，否则返 false。

这两个操作符都会先进行类型转换（也叫强制类型转换）再确定操作数是否相等。

他们都遵循如下规则：

1. 如果任一操作数是布尔值，则将其转换为数值再比较是否相等。false 转换为 0，true 转换
   为 1。

2. 如果一个操作数是字符串，另一个操作数是数值，则尝试将字符串转换为数值，再比较是否
   相等。

3. 如果一个操作数是对象，另一个操作数不是，则调用对象的 valueOf()方法取得其原始值，再
   根据前面的规则进行比较。

在进行比较时，这两个操作符会遵循如下规则。

1. null 和 undefined 相等。

2. null 和 undefined 不能转换为其他类型的值再进行比较。

3. 如果有任一操作数是 NaN，则相等操作符返回 false，不相等操作符返回 true。记住：即使两
   个操作数都是 NaN，相等操作符也返回 false，因为按照规则，NaN 不等于 NaN。

4. 如果两个操作数都是对象，则比较它们是不是同一个对象。如果两个操作数都指向同一个对象，
   则相等操作符返回 true。否则，两者不相等。

下面是特殊情况的总结：
|表达式|结果|
|--|--|
|null == undefined|true|
|"NaN" == NaN|false|
|5 == NaN|false|
|NaN == NaN|false|
|NaN != NaN|true|
|false == 0|true|
|true = 1|true|
|true == 2|false|
|undefined == 0|false|
|null == 0|false|
|"5" == 5|true|

## 全等和不全等

他们在比较相等时不转换操作数。所以他们也要判断数据类型是否相等。

另外，虽然 null == undefined 是 true（因为这两个值类似），但 null === undefined 是 false，因为它们不是相同的数据类型。

# 条件操作符

也被一些人叫做三元操作符。

```javascript
variable = boolean_expression ? true_value : false_value;
```

如果 boolean_expression 是 true ， 则赋值 true_value ； 如果 boolean_expression 是 false，则赋值 false_value。

活用它可以让代码变得简洁：

```javascript
let max = num1 > num2 ? num1 : num2;
```

但是也不过在条件内过多嵌套条件，会让代码变得难以阅读。

# 逗号操作符

一般用来同时声明多个变量：

```javascript
let num1 = 1,
  num2 = 2,
  num3 = 3;
```

还有一种少见的情况：

```javascript
let num = (5, 1, 4, 8, 0); // num 的值为0
```

在这个例子中，num 将被赋值为 0，因为 0 是表达式中最后一项。这种情况很少见，但确实存在。

# 赋值操作符

简单赋值用等于号（=）表示，将右手边的值赋给左手边的变量：

```javascript
let num = 10;
```

复杂赋值使用乘性、加性或位操作符后跟等于号（=）表示：

1. 乘后赋值（\*=）
2. 除后赋值（/=）
3. 取模后赋值（%=）
4. 加后赋值（+=）
5. 减后赋值（-=）
6. 左移后赋值（<<=）
7. 右移后赋值（>>=）
8. 无符号右移后赋值（>>>=）

这些操作符仅仅是简写语法，使用它们不会提升性能。
