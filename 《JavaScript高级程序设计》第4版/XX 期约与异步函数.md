# 期约与异步函数

ECMAScript 新增了正式的 Promise（期约）引用类型，支持优雅地定义和阻止异步逻辑。还增加了 async 和 wait 关键字定义异步函数的机制。

# 异步编程

JavaScript 是单线程事件循环模型，同步操作与异步操作是代码的核心机制。异步行为是为了优化因计算量大而时间长的操作。如果在等待的同时，即使运行其他指令，系统也能保持稳定，那么这样做就是务实的。

异步操作不一定非要用于计算量大或等待时间长的工作。只要不想因为某个操作而阻塞线程，就可以使用它。

# 同步与异步

同步行为是内存中顺序执行的处理器指令。严格按照顺序，而且每条指令执行后立即获得存储在系统本地的信息。可以很清晰地分析程序在执行中的状态。

异步行为类似于系统中断，即当前进程外部的实体可以触发代码执行。如果代码访问一些高延迟的资源，就会出现长时间的等待，这时异步操作就是必要的。

使用异步，在定时回调中执行一次简单的数学计算：

```javascript
let x = 3;
setTimeout(() => (x = x + 4), 1000);
```

这段程序也会将两数相加，但这一次线程不知道何时 X 值会改变，因为这取决于回调何时从消息队列出列并执行。

异步代码不容易推断。第二个指令块由系统计时器触发，这会生成一个入队执行的中断。到底什么时候会触发这个中断，实际无法预知（尽管可以保证发生在当前线程的同步代码执行之后，否则回调都没有机会出列被执行）。

为了让后续代码知道 x 的值何时被更新，需要一个提醒机制。这个提醒机制在后续会说明。

# 以往的异步编程方式

早期的异步方法并不理想。早期 JavaScript 只支持定义回调函数来表明异步操作。串联多个异步操作是一个常见的问题，通常需要深度嵌套的回调函数（俗称“回调地狱”）。

这种模式已经不可取且不具有扩展性，这里就不过多描述了。

# 期约

期约是对尚不存在结果的一个替身。用于描述一种异步执行程序执行的机制。

# Promises/A+规范

2010 年 CommonJS 项目实现的 Promises/A 规范日益流行。2012 年 Promises/A+组织考虑了 CommonJS 的 Promises/A，并指定 Promises/A+规范。而 ECMASCript6 增加了对 Promises/A+规范的完善支持，即 Promise 类型。

一经推出就大受欢迎，成为了主导性的异步编程机制。所有现代浏览器都支持 ES6 期约，很多其他浏览器 API（fetch()和 Battery Status API）也以期约为基础。

# 期约基础

Promise 是引用类型，可以通过 new 操作符实例化。创建新期约需要传入执行器（executor）函数作为参数（不传会抛出 SyntaxError）。下面的例子使用一个空函数对象作为执行器函数。

```javascript
let p = new Promise(() => {});
setTimeout(console.log, 0, p); // Promise <pending>
```

在把一个期约实例传给 console.log()时，控制台输出（因浏览器不同而有差异）表明该实例处于待定（pending）状态。

## 期约状态机

期约具有 3 种状态：

1. 待定（pending）

2. 兑现（fulfilled，也成为解决，resolved）

3. 拒绝（rejected）

待定（pending）是期约的最初状态。
